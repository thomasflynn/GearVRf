/* Copyright 2015 Samsung Electronics Co., LTD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gearvrf;

import org.joml.Vector3f;

/**
 * This class provides all the information corresponding to events generated by
 * a {@link GVRBaseSensor}.
 * 
 * When GVRf detects cases where a given {@link GVRBaseSensor} is activated by
 * user interaction the {@link ISensorEvents} is triggered and a
 * {@link SensorEvent} is delivered to the application.
 * 
 * Make sure that the app consumes the {@link SensorEvent} data within the
 * callback as these objects are recycled.
 *
 */
public class SensorEvent {
    private static final String TAG = SensorEvent.class.getSimpleName();
    private boolean isActive;
    private boolean isOver;
    private GVRPicker.GVRPickedObject pickedObject;
    private GVRCursorController controller;
    private EventGroup eventGroup;

    /**
     * {@link SensorEvent}s can be grouped with other {@link SensorEvent}s according to the
     * depth of the {@link GVRSceneObject} that the event occurred on. This feature can be enabled
     * or disabled using {@link GVRBaseSensor#GVRBaseSensor(GVRContext, boolean)} or
     * {@link GVRBaseSensor#depthOrderEnabled}. For eg. When a {@link GVRCursorController} changes
     * position and if that position change generated {@link SensorEvent}s on multiple
     * {@link GVRSceneObject}, the generated {@link SensorEvent}s can be sent in order of the
     * distance of the {@link GVRSceneObject} from origin, where the {@link SensorEvent}
     * associated with the {@link GVRSceneObject} closest to the origin is delivered first and
     * has an {@link EventGroup#MULTI_START} as the {@link EventGroup}. All subsequent
     * {@link SensorEvent}s in the same group have {@link EventGroup#MULTI} and are delivered in
     * depth order as described above. The last {@link SensorEvent} in that group has
     * {@link EventGroup#MULTI_STOP} as the {@link EventGroup} value. {@link SensorEvent}s that
     * occurred on only a single {@link GVRSceneObject} have {@link EventGroup#SINGLE} set as
     * their {@link EventGroup}. However when depth order is disabled all {@link SensorEvent}s
     * have the {@link EventGroup#GROUP_DISABLED} as their {@link EventGroup} value.
     * The {@link EventGroup} given to {@link SensorEvent}s can be used in apps where there are
     * multiple overlapping {@link GVRSceneObject}s and the application has to decide which of
     * the {@link GVRSceneObject}s will handle the {@link SensorEvent}.
     */
    public enum EventGroup {
        /**
         * {@link SensorEvent} has this {@link EventGroup} when the {@link SensorEvent} occurred
         * only on one {@link GVRSceneObject} and {@link GVRBaseSensor#isDepthOrderEnabled()} is
         * true.
         */
        SINGLE,
        /**
         * {@link SensorEvent} has this {@link EventGroup} when the {@link SensorEvent} occurred
         * on multiple {@link GVRSceneObject}s and {@link GVRBaseSensor#isDepthOrderEnabled()} is
         * true. This group indicates that the associated {@link GVRSceneObject} is not the
         * nearest nor the farthest from the origin among all the {@link GVRSceneObject}s that
         * the {@link SensorEvent} occurred on.
         */
        MULTI,
        /**
         * {@link SensorEvent} has this {@link EventGroup} when the {@link SensorEvent} occurred
         * on multiple {@link GVRSceneObject}s and {@link GVRBaseSensor#isDepthOrderEnabled()} is
         * true. This group indicates that the associated {@link GVRSceneObject} is the
         * nearest from the origin among all the {@link GVRSceneObject}s that
         * the {@link SensorEvent} occurred on.
         */
        MULTI_START,
        /**
         * {@link SensorEvent} has this {@link EventGroup} when the {@link SensorEvent} occurred
         * on multiple {@link GVRSceneObject}s and {@link GVRBaseSensor#isDepthOrderEnabled()} is
         * true. This group indicates that the associated {@link GVRSceneObject} is the
         * farthest from the origin among all the {@link GVRSceneObject}s that
         * the {@link SensorEvent} occurred on.
         */
        MULTI_STOP,
        /**
         * {@link SensorEvent} has this {@link EventGroup} when
         * {@link GVRBaseSensor#isDepthOrderEnabled()} is false.
         */
        GROUP_DISABLED
    }
    // We take a leaf out of the MotionEvent book to implement linked
    // recycling of objects.
    private static final int MAX_RECYCLED = 10;
    private static final Object recyclerLock = new Object();

    private static int recyclerUsed;
    private static SensorEvent recyclerTop;
    private SensorEvent next;

    public SensorEvent(){

    }

    /**
     * Set the active flag on the {@link SensorEvent}
     * 
     * @param isActive
     *            The active flag value.
     */
    void setActive(boolean isActive) {
        this.isActive = isActive;
    }

    /**
     * 
     * Set the {@link GVRCursorController} on the {@link SensorEvent}
     * 
     * @param controller
     *            The {@link GVRCursorController} that created this event
     */
    void setCursorController(GVRCursorController controller) {
        this.controller = controller;
    }

    /**
     * Set the picking information for the {@link GVRSceneObject} that
     * triggered this {@link SensorEvent}.
     * 
     * @param pickedObject
     *            The picking information of the affected {@link GVRSceneObject}.
     */
    public void setPickedObject(GVRPicker.GVRPickedObject pickedObject) {
        this.pickedObject = pickedObject;
    }

    /**
     * This flag denotes that the {@link GVRCursorController} "is over" the
     * affected pickedObject.
     * 
     * @param isOver
     *            The value of the "is over" flag.
     */
    public void setOver(boolean isOver) {
        this.isOver = isOver;
    }

    /**
     * Use this call to retrieve the picking information of the
     * affected {@link GVRSceneObject}.
     * 
     * @return The {@link GVRPicker.GVRPickedObject} corresponding to the {@link GVRSceneObject}
     *         that caused this {@link SensorEvent} to be triggered.
     */
    public GVRPicker.GVRPickedObject getPickedObject() {
        return pickedObject;
    }

    /**
     * Use this flag to detect if the input "is over" the {@link GVRSceneObject}
     * 
     * @return <code>true</code> if the input is over the corresponding
     *         {@link GVRSceneObject}. The {@link ISensorEvents} delivers
     *         multiple sensor events when this state is <code>true</code> and
     *         only one event when this state is <code>false</code>.
     * 
     */
    public boolean isOver() {
        return isOver;
    }

    /**
     * Returns the active status of the {@link SensorEvent}.
     * 
     * @return <code>true</code> when the provided input has an active state and
     *         <code>false</code> otherwise.
     * 
     *         This usually denotes a button press on a given input event. The
     *         actual interaction that causes the active state is defined by the
     *         input provided to the {@link GVRInputManagerImpl}.
     */
    public boolean isActive() {
        return isActive;
    }

    /**
     * Returns the {@link GVRCursorController} that generated this event.
     * 
     * @return the {@link GVRCursorController} object.
     */
    public GVRCursorController getCursorController() {
        return controller;
    }

    /**
     * Use this method to return a {@link SensorEvent} for use.
     * 
     * @return the {@link SensorEvent} object.
     */
    public static SensorEvent obtain() {
        final SensorEvent event;
        synchronized (recyclerLock) {
            event = recyclerTop;
            if (event == null) {
                return new SensorEvent();
            }
            recyclerTop = event.next;
            recyclerUsed -= 1;
        }
        event.next = null;
        return event;
    }

    /**
     * Recycle the {@link SensorEvent} object.
     * 
     * Make sure that the object is not used after this call.
     */
    public final void recycle() {
        synchronized (recyclerLock) {
            if (recyclerUsed < MAX_RECYCLED) {
                recyclerUsed++;
                next = recyclerTop;
                recyclerTop = this;
            }
        }
    }

    /**
     * Gets the {@link EventGroup} associated with the {@link SensorEvent}.
     * See {@link EventGroup}.
     * @return The {@link EventGroup} of the {@link SensorEvent}
     */
    public EventGroup getEventGroup() {
        return eventGroup;
    }

    void setEventGroup(EventGroup eventGroup) {
        this.eventGroup = eventGroup;
    }
}
